{"ast":null,"code":"import { fill, getFunctionName, getGlobalObject } from '@sentry/utils';\nimport { wrap } from '../helpers';\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\n\nvar TryCatch =\n/** @class */\nfunction () {\n  function TryCatch() {\n    /** JSDoc */\n    this._ignoreOnError = 0;\n    /**\n     * @inheritDoc\n     */\n\n    this.name = TryCatch.id;\n  }\n  /** JSDoc */\n\n\n  TryCatch.prototype._wrapTimeFunction = function (original) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var originalCallback = args[0];\n      args[0] = wrap(originalCallback, {\n        mechanism: {\n          data: {\n            function: getFunctionName(original)\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      });\n      return original.apply(this, args);\n    };\n  };\n  /** JSDoc */\n\n\n  TryCatch.prototype._wrapRAF = function (original) {\n    return function (callback) {\n      return original(wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original)\n          },\n          handled: true,\n          type: 'instrument'\n        }\n      }));\n    };\n  };\n  /** JSDoc */\n\n\n  TryCatch.prototype._wrapEventTarget = function (target) {\n    var global = getGlobalObject();\n    var proto = global[target] && global[target].prototype;\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (original) {\n      return function (eventName, fn, options) {\n        try {\n          // tslint:disable-next-line:no-unbound-method strict-type-predicates\n          if (typeof fn.handleEvent === 'function') {\n            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n              mechanism: {\n                data: {\n                  function: 'handleEvent',\n                  handler: getFunctionName(fn),\n                  target: target\n                },\n                handled: true,\n                type: 'instrument'\n              }\n            });\n          }\n        } catch (err) {// can sometimes get 'Permission denied to access property \"handle Event'\n        }\n\n        return original.call(this, eventName, wrap(fn, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target: target\n            },\n            handled: true,\n            type: 'instrument'\n          }\n        }), options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (original) {\n      return function (eventName, fn, options) {\n        var callback = fn;\n\n        try {\n          callback = callback && (callback.__sentry_wrapped__ || callback);\n        } catch (e) {// ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n\n        return original.call(this, eventName, callback, options);\n      };\n    });\n  };\n  /** JSDoc */\n\n\n  TryCatch.prototype._wrapXHR = function (originalSend) {\n    return function () {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var xhr = this; // tslint:disable-line:no-this-assignment\n\n      var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress'];\n      xmlHttpRequestProps.forEach(function (prop) {\n        if (prop in _this && typeof _this[prop] === 'function') {\n          fill(_this, prop, function (original) {\n            return wrap(original, {\n              mechanism: {\n                data: {\n                  function: prop,\n                  handler: getFunctionName(original)\n                },\n                handled: true,\n                type: 'instrument'\n              }\n            });\n          });\n        }\n      });\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          var wrapOptions = {\n            mechanism: {\n              data: {\n                function: 'onreadystatechange',\n                handler: getFunctionName(original)\n              },\n              handled: true,\n              type: 'instrument'\n            }\n          }; // If Instrument integration has been called before TryCatch, get the name of original function\n\n          if (original.__sentry_original__) {\n            wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);\n          } // Otherwise wrap directly\n\n\n          return wrap(original, wrapOptions);\n        });\n      }\n\n      return originalSend.apply(this, args);\n    };\n  };\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n\n\n  TryCatch.prototype.setupOnce = function () {\n    this._ignoreOnError = this._ignoreOnError;\n    var global = getGlobalObject();\n    fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));\n    fill(global, 'setInterval', this._wrapTimeFunction.bind(this));\n    fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));\n\n    if ('XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', this._wrapXHR.bind(this));\n    }\n\n    ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'].forEach(this._wrapEventTarget.bind(this));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TryCatch.id = 'TryCatch';\n  return TryCatch;\n}();\n\nexport { TryCatch };","map":{"version":3,"sources":["../../src/integrations/trycatch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { fill, getFunctionName, getGlobalObject } from '@sentry/utils';\n\nimport { wrap } from '../helpers';\n\ntype XMLHttpRequestProp = 'onload' | 'onerror' | 'onprogress';\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nexport class TryCatch implements Integration {\n  /** JSDoc */\n  private _ignoreOnError: number = 0;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = TryCatch.id;\n\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'TryCatch';\n\n  /** JSDoc */\n  private _wrapTimeFunction(original: () => void): () => number {\n    return function(this: any, ...args: any[]): number {\n      const originalCallback = args[0];\n      args[0] = wrap(originalCallback, {\n        mechanism: {\n          data: { function: getFunctionName(original) },\n          handled: true,\n          type: 'instrument',\n        },\n      });\n      return original.apply(this, args);\n    };\n  }\n\n  /** JSDoc */\n  private _wrapRAF(original: any): (callback: () => void) => any {\n    return function(this: any, callback: () => void): () => void {\n      return original(\n        wrap(callback, {\n          mechanism: {\n            data: {\n              function: 'requestAnimationFrame',\n              handler: getFunctionName(original),\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n      );\n    };\n  }\n\n  /** JSDoc */\n  private _wrapEventTarget(target: string): void {\n    const global = getGlobalObject() as { [key: string]: any };\n    const proto = global[target] && global[target].prototype;\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function(\n      original: () => void,\n    ): (eventName: string, fn: EventListenerObject, options?: boolean | AddEventListenerOptions) => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): (eventName: string, fn: EventListenerObject, capture?: boolean, secure?: boolean) => void {\n        try {\n          // tslint:disable-next-line:no-unbound-method strict-type-predicates\n          if (typeof fn.handleEvent === 'function') {\n            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {\n              mechanism: {\n                data: {\n                  function: 'handleEvent',\n                  handler: getFunctionName(fn),\n                  target,\n                },\n                handled: true,\n                type: 'instrument',\n              },\n            });\n          }\n        } catch (err) {\n          // can sometimes get 'Permission denied to access property \"handle Event'\n        }\n\n        return original.call(\n          this,\n          eventName,\n          wrap((fn as any) as WrappedFunction, {\n            mechanism: {\n              data: {\n                function: 'addEventListener',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          }),\n          options,\n        );\n      };\n    });\n\n    fill(proto, 'removeEventListener', function(\n      original: () => void,\n    ): (this: any, eventName: string, fn: EventListenerObject, options?: boolean | EventListenerOptions) => () => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        let callback = (fn as any) as WrappedFunction;\n        try {\n          callback = callback && (callback.__sentry_wrapped__ || callback);\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return original.call(this, eventName, callback, options);\n      };\n    });\n  }\n\n  /** JSDoc */\n  private _wrapXHR(originalSend: () => void): () => void {\n    return function(this: XMLHttpRequest, ...args: any[]): void {\n      const xhr = this; // tslint:disable-line:no-this-assignment\n      const xmlHttpRequestProps: XMLHttpRequestProp[] = ['onload', 'onerror', 'onprogress'];\n\n      xmlHttpRequestProps.forEach(prop => {\n        if (prop in this && typeof this[prop] === 'function') {\n          fill(this, prop, original =>\n            wrap(original, {\n              mechanism: {\n                data: {\n                  function: prop,\n                  handler: getFunctionName(original),\n                },\n                handled: true,\n                type: 'instrument',\n              },\n            }),\n          );\n        }\n      });\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function(original: WrappedFunction): Function {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: 'onreadystatechange',\n                handler: getFunctionName(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          if (original.__sentry_original__) {\n            wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n\n      return originalSend.apply(this, args);\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n  public setupOnce(): void {\n    this._ignoreOnError = this._ignoreOnError;\n\n    const global = getGlobalObject();\n\n    fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));\n    fill(global, 'setInterval', this._wrapTimeFunction.bind(this));\n    fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));\n\n    if ('XMLHttpRequest' in global) {\n      fill(XMLHttpRequest.prototype, 'send', this._wrapXHR.bind(this));\n    }\n\n    [\n      'EventTarget',\n      'Window',\n      'Node',\n      'ApplicationCache',\n      'AudioTrackList',\n      'ChannelMergerNode',\n      'CryptoOperation',\n      'EventSource',\n      'FileReader',\n      'HTMLUnknownElement',\n      'IDBDatabase',\n      'IDBRequest',\n      'IDBTransaction',\n      'KeyOperation',\n      'MediaController',\n      'MessagePort',\n      'ModalWindow',\n      'Notification',\n      'SVGElementInstance',\n      'Screen',\n      'TextTrack',\n      'TextTrackCue',\n      'TextTrackList',\n      'WebSocket',\n      'WebSocketWorker',\n      'Worker',\n      'XMLHttpRequest',\n      'XMLHttpRequestEventTarget',\n      'XMLHttpRequestUpload',\n    ].forEach(this._wrapEventTarget.bind(this));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}