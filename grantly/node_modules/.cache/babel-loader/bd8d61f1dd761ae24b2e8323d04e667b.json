{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { getEventDescription, isMatchingPattern, logger } from '@sentry/utils'; // \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\n\nvar DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n/** Inbound filters configurable by the user */\n\nvar InboundFilters =\n/** @class */\nfunction () {\n  function InboundFilters(_options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    this._options = _options;\n    /**\n     * @inheritDoc\n     */\n\n    this.name = InboundFilters.id;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  InboundFilters.prototype.setupOnce = function () {\n    addGlobalEventProcessor(function (event) {\n      var hub = getCurrentHub();\n\n      if (!hub) {\n        return event;\n      }\n\n      var self = hub.getIntegration(InboundFilters);\n\n      if (self) {\n        var client = hub.getClient();\n        var clientOptions = client ? client.getOptions() : {};\n\n        var options = self._mergeOptions(clientOptions);\n\n        if (self._shouldDropEvent(event, options)) {\n          return null;\n        }\n      }\n\n      return event;\n    });\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._shouldDropEvent = function (event, options) {\n    if (this._isSentryError(event, options)) {\n      logger.warn(\"Event dropped due to being internal Sentry Error.\\nEvent: \" + getEventDescription(event));\n      return true;\n    }\n\n    if (this._isIgnoredError(event, options)) {\n      logger.warn(\"Event dropped due to being matched by `ignoreErrors` option.\\nEvent: \" + getEventDescription(event));\n      return true;\n    }\n\n    if (this._isBlacklistedUrl(event, options)) {\n      logger.warn(\"Event dropped due to being matched by `blacklistUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + this._getEventFilterUrl(event));\n      return true;\n    }\n\n    if (!this._isWhitelistedUrl(event, options)) {\n      logger.warn(\"Event dropped due to not being matched by `whitelistUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + this._getEventFilterUrl(event));\n      return true;\n    }\n\n    return false;\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._isSentryError = function (event, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!options.ignoreInternal) {\n      return false;\n    }\n\n    try {\n      return event && event.exception && event.exception.values && event.exception.values[0] && event.exception.values[0].type === 'SentryError' || false;\n    } catch (_oO) {\n      return false;\n    }\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._isIgnoredError = function (event, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!options.ignoreErrors || !options.ignoreErrors.length) {\n      return false;\n    }\n\n    return this._getPossibleEventMessages(event).some(function (message) {\n      // Not sure why TypeScript complains here...\n      return options.ignoreErrors.some(function (pattern) {\n        return isMatchingPattern(message, pattern);\n      });\n    });\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._isBlacklistedUrl = function (event, options) {\n    if (options === void 0) {\n      options = {};\n    } // TODO: Use Glob instead?\n\n\n    if (!options.blacklistUrls || !options.blacklistUrls.length) {\n      return false;\n    }\n\n    var url = this._getEventFilterUrl(event);\n\n    return !url ? false : options.blacklistUrls.some(function (pattern) {\n      return isMatchingPattern(url, pattern);\n    });\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._isWhitelistedUrl = function (event, options) {\n    if (options === void 0) {\n      options = {};\n    } // TODO: Use Glob instead?\n\n\n    if (!options.whitelistUrls || !options.whitelistUrls.length) {\n      return true;\n    }\n\n    var url = this._getEventFilterUrl(event);\n\n    return !url ? true : options.whitelistUrls.some(function (pattern) {\n      return isMatchingPattern(url, pattern);\n    });\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._mergeOptions = function (clientOptions) {\n    if (clientOptions === void 0) {\n      clientOptions = {};\n    }\n\n    return {\n      blacklistUrls: tslib_1.__spread(this._options.blacklistUrls || [], clientOptions.blacklistUrls || []),\n      ignoreErrors: tslib_1.__spread(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),\n      ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true,\n      whitelistUrls: tslib_1.__spread(this._options.whitelistUrls || [], clientOptions.whitelistUrls || [])\n    };\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._getPossibleEventMessages = function (event) {\n    if (event.message) {\n      return [event.message];\n    }\n\n    if (event.exception) {\n      try {\n        var _a = event.exception.values && event.exception.values[0] || {},\n            _b = _a.type,\n            type = _b === void 0 ? '' : _b,\n            _c = _a.value,\n            value = _c === void 0 ? '' : _c;\n\n        return [\"\" + value, type + \": \" + value];\n      } catch (oO) {\n        logger.error(\"Cannot extract message for event \" + getEventDescription(event));\n        return [];\n      }\n    }\n\n    return [];\n  };\n  /** JSDoc */\n\n\n  InboundFilters.prototype._getEventFilterUrl = function (event) {\n    try {\n      if (event.stacktrace) {\n        var frames_1 = event.stacktrace.frames;\n        return frames_1 && frames_1[frames_1.length - 1].filename || null;\n      }\n\n      if (event.exception) {\n        var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;\n        return frames_2 && frames_2[frames_2.length - 1].filename || null;\n      }\n\n      return null;\n    } catch (oO) {\n      logger.error(\"Cannot extract url for event \" + getEventDescription(event));\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  InboundFilters.id = 'InboundFilters';\n  return InboundFilters;\n}();\n\nexport { InboundFilters };","map":{"version":3,"sources":["../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Event, Integration } from '@sentry/types';\nimport { getEventDescription, isMatchingPattern, logger } from '@sentry/utils';\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** JSDoc */\ninterface InboundFiltersOptions {\n  blacklistUrls?: Array<string | RegExp>;\n  ignoreErrors?: Array<string | RegExp>;\n  ignoreInternal?: boolean;\n  whitelistUrls?: Array<string | RegExp>;\n}\n\n/** Inbound filters configurable by the user */\nexport class InboundFilters implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public name: string = InboundFilters.id;\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'InboundFilters';\n\n  public constructor(private readonly _options: InboundFiltersOptions = {}) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    addGlobalEventProcessor((event: Event) => {\n      const hub = getCurrentHub();\n      if (!hub) {\n        return event;\n      }\n      const self = hub.getIntegration(InboundFilters);\n      if (self) {\n        const client = hub.getClient();\n        const clientOptions = client ? client.getOptions() : {};\n        const options = self._mergeOptions(clientOptions);\n        if (self._shouldDropEvent(event, options)) {\n          return null;\n        }\n      }\n      return event;\n    });\n  }\n\n  /** JSDoc */\n  private _shouldDropEvent(event: Event, options: InboundFiltersOptions): boolean {\n    if (this._isSentryError(event, options)) {\n      logger.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${getEventDescription(event)}`);\n      return true;\n    }\n    if (this._isIgnoredError(event, options)) {\n      logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${getEventDescription(event)}`,\n      );\n      return true;\n    }\n    if (this._isBlacklistedUrl(event, options)) {\n      logger.warn(\n        `Event dropped due to being matched by \\`blacklistUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${this._getEventFilterUrl(event)}`,\n      );\n      return true;\n    }\n    if (!this._isWhitelistedUrl(event, options)) {\n      logger.warn(\n        `Event dropped due to not being matched by \\`whitelistUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${this._getEventFilterUrl(event)}`,\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /** JSDoc */\n  private _isSentryError(event: Event, options: InboundFiltersOptions = {}): boolean {\n    if (!options.ignoreInternal) {\n      return false;\n    }\n\n    try {\n      return (\n        (event &&\n          event.exception &&\n          event.exception.values &&\n          event.exception.values[0] &&\n          event.exception.values[0].type === 'SentryError') ||\n        false\n      );\n    } catch (_oO) {\n      return false;\n    }\n  }\n\n  /** JSDoc */\n  private _isIgnoredError(event: Event, options: InboundFiltersOptions = {}): boolean {\n    if (!options.ignoreErrors || !options.ignoreErrors.length) {\n      return false;\n    }\n\n    return this._getPossibleEventMessages(event).some(message =>\n      // Not sure why TypeScript complains here...\n      (options.ignoreErrors as Array<RegExp | string>).some(pattern => isMatchingPattern(message, pattern)),\n    );\n  }\n\n  /** JSDoc */\n  private _isBlacklistedUrl(event: Event, options: InboundFiltersOptions = {}): boolean {\n    // TODO: Use Glob instead?\n    if (!options.blacklistUrls || !options.blacklistUrls.length) {\n      return false;\n    }\n    const url = this._getEventFilterUrl(event);\n    return !url ? false : options.blacklistUrls.some(pattern => isMatchingPattern(url, pattern));\n  }\n\n  /** JSDoc */\n  private _isWhitelistedUrl(event: Event, options: InboundFiltersOptions = {}): boolean {\n    // TODO: Use Glob instead?\n    if (!options.whitelistUrls || !options.whitelistUrls.length) {\n      return true;\n    }\n    const url = this._getEventFilterUrl(event);\n    return !url ? true : options.whitelistUrls.some(pattern => isMatchingPattern(url, pattern));\n  }\n\n  /** JSDoc */\n  private _mergeOptions(clientOptions: InboundFiltersOptions = {}): InboundFiltersOptions {\n    return {\n      blacklistUrls: [...(this._options.blacklistUrls || []), ...(clientOptions.blacklistUrls || [])],\n      ignoreErrors: [\n        ...(this._options.ignoreErrors || []),\n        ...(clientOptions.ignoreErrors || []),\n        ...DEFAULT_IGNORE_ERRORS,\n      ],\n      ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true,\n      whitelistUrls: [...(this._options.whitelistUrls || []), ...(clientOptions.whitelistUrls || [])],\n    };\n  }\n\n  /** JSDoc */\n  private _getPossibleEventMessages(event: Event): string[] {\n    if (event.message) {\n      return [event.message];\n    }\n    if (event.exception) {\n      try {\n        const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n        return [`${value}`, `${type}: ${value}`];\n      } catch (oO) {\n        logger.error(`Cannot extract message for event ${getEventDescription(event)}`);\n        return [];\n      }\n    }\n    return [];\n  }\n\n  /** JSDoc */\n  private _getEventFilterUrl(event: Event): string | null {\n    try {\n      if (event.stacktrace) {\n        const frames = event.stacktrace.frames;\n        return (frames && frames[frames.length - 1].filename) || null;\n      }\n      if (event.exception) {\n        const frames =\n          event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;\n        return (frames && frames[frames.length - 1].filename) || null;\n      }\n      return null;\n    } catch (oO) {\n      logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n      return null;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}